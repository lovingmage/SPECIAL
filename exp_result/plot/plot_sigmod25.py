# -*- coding: utf-8 -*-
"""plot_sigmod25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cs3T0pYDsYlt-2sZQcfb2eP0nR3BJnsn
"""

import matplotlib.pyplot as plt
import numpy as np
from google.colab import files

# Data
bars1_actual = [220, 1241, 129485, 163715, 0, 0, 0, 0]  # Actual values for bars1 (10% data for groups 4 and 5)
bars1_projected = [220, 1241, 129485, 16371500, 0, 0, 0, 0]  # Projected values for bars1
bars2 = [1192, 10855, 44121, 964551, 3024632, 58342782, 63123774, 65191036]
bars3 = [10, 3, 13174, 143572, 228916, 1893022, 785738, 899011]

# Calculate slowdowns using projected values
slowdown1 = [b1/b3 if b3 != 0 else 0 for b1, b3 in zip(bars1_projected, bars3)]
slowdown2 = [b2/b3 if b3 != 0 else 0 for b2, b3 in zip(bars2, bars3)]

# Set the width of the bars
barWidth = 0.25

# Set the position of the bars on the x-axis
r1 = range(len(bars1_actual))
r2 = [x + barWidth for x in r1]
r3 = [x + barWidth for x in r2]

# Make the plot
plt.figure(figsize=(9.9, 3.3))  # Make the figure wider
for idx in range(len(bars1_actual)):
    if idx in [3, 4]:  # Add shadow for bars1 group 4,5
        plt.bar(r1[idx], bars1_actual[idx], color='burlywood', width=barWidth, edgecolor='black', alpha=0.5, zorder=3)
    else:
        plt.bar(r1[idx], bars1_actual[idx], color='burlywood', width=barWidth, edgecolor='black', zorder=3)
plt.bar(r2, bars2, color='antiquewhite', width=barWidth, edgecolor='black', hatch='/', label='Shrinkwrap', zorder=3)
plt.bar(r3, bars3, color='steelblue', width=barWidth, edgecolor='black', label='SPECIAL', zorder=3)

# Add slowdown labels
for idx in range(len(bars1_projected)):
    if slowdown1[idx] != 0:
        plt.text(r1[idx], bars1_projected[idx], f'{slowdown1[idx]:.1f}x', ha='center', va='bottom', zorder=4, fontweight='bold', fontsize=12, color='grey')
    if slowdown2[idx] != 0:
        plt.text(r2[idx], bars2[idx], f'{slowdown2[idx]:.1f}x', ha='center', va='bottom', zorder=4, fontweight='bold', fontsize=12)

# Draw a dashed rectangle to indicate projected values for groups 4 and 5
for idx in [3, 4]:
    plt.gca().add_patch(plt.Rectangle((r1[idx]-barWidth/2, bars1_actual[idx]), barWidth, bars1_projected[idx] - bars1_actual[idx], fill=False, edgecolor='blue', linestyle='--', linewidth=2, zorder=4))

# Add xticks on the middle of the group bars
#plt.xlabel('Group', fontweight='bold', fontsize=12)
plt.xticks([r + barWidth for r in range(len(bars1_actual))], ['Q1', 'Q2', 'Q3', 'Q4', 'Q5', 'Q6', 'Q7', 'Q8'], fontsize=18)

# Set the y-axis to a logarithmic scale
plt.ylabel('Query time (ms)', fontweight='bold', fontsize=12)
plt.yscale('log')

# Create legend & Show graphic
plt.bar([0], [0], color='burlywood', label='SMCQL')
plt.legend(fontsize=12)
plt.grid(axis='y', zorder=0)
plt.ylim(0, 10**9)
plt.tight_layout()
plt.savefig("latency.pdf")
files.download("latency.pdf")
plt.show()

# Data
bars1_actual = [701616, 4448496, 4151482608, 3427568736, 0, 0, 0, 0]  # Actual values for bars1 (10% data for groups 4 and 5)
bars1_projected = [701616, 4448496, 4151482608, 342298599360, 0, 0, 0, 0]  # Projected values for bars1
bars2 = [354240, 2033280, 6063528, 103545216, 259764576, 3354165360, 3442483968, 3442889952]
bars3 = [8016, 4176, 98832, 424440, 1055224, 5651880, 3708936, 4368288]

# Calculate slowdowns using projected values
slowdown1 = [b1/b3 if b3 != 0 else 0 for b1, b3 in zip(bars1_projected, bars3)]
slowdown2 = [b2/b3 if b3 != 0 else 0 for b2, b3 in zip(bars2, bars3)]

# Set the width of the bars
barWidth = 0.25

# Set the position of the bars on the x-axis
r1 = range(len(bars1_actual))
r2 = [x + barWidth for x in r1]
r3 = [x + barWidth for x in r2]

# Make the plot
plt.figure(figsize=(9.9, 3.3))  # Make the figure wider
for idx in range(len(bars1_actual)):
    if idx in [3, 4]:  # Add shadow for bars1 group 4,5
        plt.bar(r1[idx], bars1_actual[idx], color='burlywood', width=barWidth, edgecolor='black', alpha=0.5, zorder=3)
    else:
        plt.bar(r1[idx], bars1_actual[idx], color='burlywood', width=barWidth, edgecolor='black', zorder=3)
plt.bar(r2, bars2, color='antiquewhite', width=barWidth, edgecolor='black', hatch='/', label='Shrinkwrap', zorder=3)
plt.bar(r3, bars3, color='steelblue', width=barWidth, edgecolor='black', label='SPECIAL', zorder=3)

# Add slowdown labels
for idx in range(len(bars1_projected)):
    if slowdown1[idx] != 0:
        plt.text(r1[idx], bars1_projected[idx]*2 , f'{slowdown1[idx]:.1f}x', ha='center', va='bottom', zorder=4, fontweight='bold', fontsize=12, color='grey')
    if slowdown2[idx] != 0:
        plt.text(r2[idx], bars2[idx] , f'{slowdown2[idx]:.1f}x', ha='center', va='bottom', zorder=4, fontweight='bold', fontsize=12)

# Draw a dashed rectangle to indicate projected values for groups 4 and 5
for idx in [3, 4]:
    plt.gca().add_patch(plt.Rectangle((r1[idx]-barWidth/2, bars1_actual[idx]), barWidth, bars1_projected[idx] - bars1_actual[idx], fill=False, edgecolor='blue', linestyle='--', linewidth=2, zorder=4))

# Add xticks on the middle of the group bars
#plt.xlabel('Group', fontweight='bold', fontsize=12)
plt.xticks([r + barWidth for r in range(len(bars1_actual))], ['Q1', 'Q2', 'Q3', 'Q4', 'Q5', 'Q6', 'Q7', 'Q8'], fontsize=18)

# Set the y-axis to a logarithmic scale
plt.ylabel('Memory usage (Bytes)', fontweight='bold', fontsize=12)
plt.yscale('log')

# Create legend & Show graphic
plt.bar([0], [0], color='burlywood', label='SMCQL')
plt.legend(fontsize=12, loc='upper left')
plt.grid(axis='y', zorder=0)
plt.ylim(0, 10**13)
plt.tight_layout()
plt.savefig("memory.pdf")
files.download("memory.pdf")
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm

# CDP composition formula
def cdp_composition(rho, k, delta):
    if k == 1:
        return 1.5  # Ensure privacy loss is equal to 1.5 when k=1
    return np.sqrt(2 * k * rho) * norm.ppf(1 - delta)

# Parameters for fixed DP
epsilon_fixed = 1.5
delta_fixed = 0.00005

# Calculate rho from epsilon and delta for CDP composition
rho_from_epsilon_delta = 1.5**2 / 2

# Number of queries (k)
k_values = np.linspace(1, 100, 100)  # Start from k=2

# Compute CDP composition privacy loss using the calculated rho
cdp_epsilon_values_from_epsilon_delta = [cdp_composition(rho_from_epsilon_delta, k, delta_fixed) for k in k_values]

# Fixed epsilon value (no composition)
fixed_epsilon_values = [epsilon_fixed for _ in k_values]

# Find the crossover point where CDP composition exceeds fixed epsilon
crossover_k_cdp = next(k for k, epsilon in enumerate(cdp_epsilon_values_from_epsilon_delta) if epsilon > epsilon_fixed)

# Plotting
plt.figure(figsize=(4.5, 2.7))
plt.plot(k_values, cdp_epsilon_values_from_epsilon_delta, label='Shrinkwrap', linewidth=3, color='tan')
plt.plot(k_values, fixed_epsilon_values, label='SPECIAL', linestyle='--', linewidth=3, color='steelblue', marker='o', markevery=9)

# Compute and annotate the ratio at k=10, 50, 100 with vertical dash segments
for k in [10, 50, 100]:
    cdp_value = cdp_composition(rho_from_epsilon_delta, k, delta_fixed)
    ratio = cdp_value / epsilon_fixed
    plt.plot([k, k], [epsilon_fixed, cdp_value], linestyle='--', color='gray', linewidth=1)
    if k == 10:
        plt.text(k+5, (epsilon_fixed + cdp_value), f'{ratio:.2f}x', ha='right', fontsize=12)
    else:
        plt.text(k, (epsilon_fixed + cdp_value) / 1.5, f'{ratio:.2f}x', ha='right', fontsize=12)

# Labels and title
plt.xlabel('Number of Queries', fontweight='bold', fontsize=10)
plt.ylabel('Privacy Loss ($\\epsilon$)', fontweight='bold', fontsize=10)

# Grid and legend
plt.grid(True)
plt.legend(fontsize=12)
plt.title("Adv. Composition", fontsize=14)

plt.tight_layout()
plt.savefig("cdp.pdf")
files.download("cdp.pdf")
# Show plot
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm

# Advanced composition formula
def advanced_composition(epsilon, delta, k, delta_prime):
    if k == 1:
        return 1.5  # Ensure privacy loss is equal to epsilon when k=1
    return 2 * epsilon * np.sqrt(2 * k * np.log(1 / delta_prime))

# Parameters for fixed DP
epsilon_fixed = 1.5
delta_fixed = 0.00005

# Parameters for advanced composition
epsilon_adv = 1.5
delta_adv = 0.00005
delta_prime_adv = delta_adv  # Assuming delta_prime = delta for simplicity

# Number of queries (k)
k_values = np.linspace(1, 100, 100)

# Compute advanced composition privacy loss
advanced_epsilon_values = [advanced_composition(epsilon_adv, delta_adv, k, delta_prime_adv) for k in k_values]

# Fixed epsilon value (no composition)
fixed_epsilon_values = [epsilon_fixed for _ in k_values]

# Plotting
plt.figure(figsize=(4.5, 2.7))
plt.plot(k_values, advanced_epsilon_values, label='Shrinkwrap', linewidth=3, color='tan')
plt.plot(k_values, fixed_epsilon_values, label='SPECIAL', linestyle='--', linewidth=3, color='steelblue', marker='o', markevery=9)

# Compute and annotate the ratio at k=10, 50, 100 with vertical dash segments
for k in [10, 50, 100]:
    adv_value = advanced_composition(epsilon_adv, delta_adv, k, delta_prime_adv)
    ratio = adv_value / epsilon_fixed
    plt.plot([k, k], [epsilon_fixed, adv_value], linestyle='--', color='gray', linewidth=1)
    if k == 10:
        plt.text(k+5, (epsilon_fixed + adv_value), f'{ratio:.2f}x', ha='right', fontsize=12)
    else:
        plt.text(k, (epsilon_fixed + adv_value) / 1.5, f'{ratio:.2f}x', ha='right', fontsize=12)

# Labels and title
plt.xlabel('Number of Queries', fontweight='bold', fontsize=10)
plt.ylabel('Privacy Loss ($\\epsilon$)', fontweight='bold', fontsize=10)

# Grid and legend
plt.grid(True)
plt.legend(fontsize=12)
plt.title("CDP. Composition", fontsize=14)


plt.tight_layout()
plt.savefig("adv.pdf")
files.download("adv.pdf")
# Show plot
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm

# Number of queries (k)
k_values = [0.1, 0.2, 0.5, 1, 10]

# Perf results
linear = [7, 6, 5, 4, 4]
binary = [239370, 196398, 158389, 147642, 145074]
multi = [3345941, 2093380, 1323213, 1001481, 1017349]

# Create subplots
fig, axs = plt.subplots(nrows=1, ncols=3, figsize=(9.9, 3.3))

# Plotting
axs[0].plot(k_values, linear, label='Linear (Q2)', linestyle='--', linewidth=3, color='steelblue', marker='o', markevery=0.1)
axs[1].plot(k_values, binary, label='Binary Join (Q4)', linestyle='--', linewidth=3, color='steelblue', marker='o')
axs[2].plot(k_values, multi, label='Multi Join (Q8)', linestyle='--', linewidth=3, color='steelblue', marker='o')

# Labels and title for each subplot
for ax in axs:
    ax.set_ylabel('Query time (ms)', fontweight='bold', fontsize=12)
    ax.set_xlabel('Privacy Loss ($\\epsilon$)', fontweight='bold', fontsize=12)
    ax.grid(True)
    ax.legend(fontsize=12)
    ax.set_xscale('log')
    #ax.set_yscale('log')

# Adjust layout
plt.tight_layout()
plt.savefig("eps_time.pdf")
files.download("eps_time.pdf")

# Show plot
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm

# Number of queries (k)
k_values = [0.1, 0.2, 0.5, 1, 10]

# Perf results
linear = [6864, 5712, 5136, 4560, 4176]
binary = [448080, 433320, 427800, 424728, 424440]
multi = [13316976, 9097152, 6371088, 4247328, 3835464]

# Create subplots
fig, axs = plt.subplots(nrows=1, ncols=3, figsize=(9.9, 3.3))

# Plotting
axs[0].plot(k_values, linear, label='Linear (Q2)', linestyle='--', linewidth=3, color='steelblue', marker='o', markevery=0.1)
axs[1].plot(k_values, binary, label='Binary Join (Q4)', linestyle='--', linewidth=3, color='steelblue', marker='o')
axs[2].plot(k_values, multi, label='Multi Join (Q8)', linestyle='--', linewidth=3, color='steelblue', marker='o')

# Labels and title for each subplot
for ax in axs:
    ax.set_ylabel('Memory usage (bytes)', fontweight='bold', fontsize=12)
    ax.set_xlabel('Privacy Loss ($\\epsilon$)', fontweight='bold', fontsize=12)
    ax.grid(True)
    ax.legend(fontsize=12)
    ax.set_xscale('log')
    #ax.set_yscale('log')

# Adjust layout
plt.tight_layout()
plt.savefig("eps_mem.pdf")
files.download("eps_mem.pdf")

# Show plot
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Random data for demonstration
group1 = [7, 14, 28]
group2 = [723372, 3588842, 17815199]
group3 = [3444690, 17036028, 0]
projected_value = 4.9 * group3[1]  # Projected value for group 3, 3rd value

# Set the width of the bars
barWidth = 0.25

# Set the position of the bars on the x-axis
r1 = np.arange(len(group1))
r2 = [x + barWidth for x in r1]
r3 = [x + barWidth for x in r2]

# Make the plot
plt.figure(figsize=(4.5, 2.7))
plt.bar(r1, group1, color='lightsteelblue', width=barWidth, edgecolor='black', label='Linear (Q2)')
plt.bar(r2, group2, color='aliceblue', width=barWidth, hatch='/', edgecolor='black', label='Binary Join (Q4)')
plt.bar(r3, group3, color='steelblue', width=barWidth, edgecolor='black', label='Multi Join (Q8)')

# Add xticks on the middle of the group bars
plt.xticks([r + barWidth for r in range(len(group1))], ['2x (2.2M)', '4x (4.4M)', '8x (8.8M)'])

# Add labels
plt.xlabel('Scaling factors', fontweight='bold', fontsize=10)
plt.ylabel('Query time (ms)', fontweight='bold', fontsize=10)

# Create legend & Show graphic
plt.legend()

# Set the y-axis to a logarithmic scale
plt.yscale('log')
plt.title("Query Time", fontsize=14)

# Draw a dashed rectangle to indicate the projected value for group 3
#plt.gca().add_patch(plt.Rectangle((r3[2] - barWidth / 2, 0), barWidth, projected_value - group3[1], fill=True, edgecolor='blue', linestyle='dashed', linewidth=2, alpha=0.5, facecolor='steelblue', zorder=3))

# Adjust layout and show the plot
plt.ylim(0, 10**11)
plt.tight_layout()
plt.savefig("scale_time.pdf")
files.download("scale_time.pdf")
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Random data for demonstration
group1 = [4176, 8352, 16704]
group2 = [848208, 1695936, 3391200]
group3 = [41264976, 210199728, 0]
projected_value = 4.9 * group3[1]  # Projected value for group 3, 3rd value

# Set the width of the bars
barWidth = 0.25

# Set the position of the bars on the x-axis
r1 = np.arange(len(group1))
r2 = [x + barWidth for x in r1]
r3 = [x + barWidth for x in r2]

# Make the plot
plt.figure(figsize=(4.5, 2.7))
plt.bar(r1, group1, color='lightsteelblue', width=barWidth, edgecolor='black', label='Linear (Q2)')
plt.bar(r2, group2, color='aliceblue', width=barWidth, hatch='/', edgecolor='black', label='Binary Join (Q4)')
plt.bar(r3, group3, color='steelblue', width=barWidth, edgecolor='black', label='Multi Join (Q8)')

# Add xticks on the middle of the group bars
plt.xticks([r + barWidth for r in range(len(group1))], ['2x (2.2M)', '4x (4.4M)', '8x (8.8M)'])

# Add labels
plt.xlabel('Scaling factors', fontweight='bold', fontsize=10)
plt.ylabel('Memory usage (bytes)', fontweight='bold', fontsize=10)

# Create legend & Show graphic
plt.legend()

# Set the y-axis to a logarithmic scale
plt.yscale('log')
plt.title("Memory Usage", fontsize=14)


# Draw a dashed rectangle to indicate the projected value for group 3
#plt.gca().add_patch(plt.Rectangle((r3[2] - barWidth / 2, 0), barWidth, projected_value - group3[1], fill=True, edgecolor='blue', linestyle='dashed', linewidth=2, alpha=0.5, facecolor='steelblue', zorder=3))

# Adjust layout and show the plot
plt.ylim(0, 10**11)
plt.tight_layout()
plt.savefig("scale_mem.pdf")
files.download("scale_mem.pdf")
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Set the seed for reproducibility
np.random.seed(0)

# Generate attribute values
attribute_values = np.arange(1, 101)

# Generate log-normal distributed data and scale it
values = np.random.lognormal(mean=3.0, sigma=0.4, size=1000)
scaled_values = np.clip((values / np.max(values)) * 100, 1, 100).astype(int)

# Create the cumulative count for the CDF
counts = np.bincount(scaled_values, minlength=101)[1:]  # Ensure 100 elements
cumulative_counts = np.cumsum(counts)

# Generate smooth overestimation and underestimation curves
overestimation_smooth = cumulative_counts + np.linspace(10, 50, num=100)  # Gradually increasing overestimation
underestimation_smooth = cumulative_counts - np.linspace(10, 50, num=100)  # Gradually decreasing underestimation
underestimation_smooth = np.maximum(underestimation_smooth, 0)  # Ensure non-negative values

# Calculate specific points for annotations
lo = cumulative_counts[22]  # Real CDF at x=23
hi = cumulative_counts[23]  # Real CDF at x=24
lo2 = int(underestimation_smooth[22])  # Underestimate CDF at x=23
hi2 = int(overestimation_smooth[23])  # Overestimate CDF at x=24

# Create the plots with annotations and legends
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))

# Full CDF on the left
ax1.step(attribute_values, cumulative_counts, where='mid', label='Raw CF, $g(x)$', color='blue')
ax1.axhspan(lo, hi, color='steelblue', alpha=0.7, label='Index range for x=24')
ax1.annotate(f'$g(23) = {lo}$', xy=(23, lo), xytext=(19, lo-100), color='dimgray', fontsize=11, arrowprops=dict(color='dimgray', arrowstyle='->'), horizontalalignment='right')
ax1.annotate(f'$g(24) = {hi}$', xy=(24, hi), xytext=(28, hi+100), color='dimgray', fontsize=11, arrowprops=dict(color='dimgray', arrowstyle='->'), horizontalalignment='left')
ax1.set_title('Example of CF based Indexes')
ax1.set_xlabel('Attribute Values')
ax1.set_ylabel('Sorted Array Offset (CF)')
ax1.grid(True)
ax1.legend(fontsize=11)

# Zoomed CDF on the right
ax2.step(attribute_values[19:31], cumulative_counts[19:31], where='mid', color='blue', label='Raw CF, $g(x)$')
ax2.step(attribute_values[19:31], overestimation_smooth[19:31], where='mid', linestyle='--', color='burlywood', label='Overestimate CF, $g^{+}(x)$', linewidth=2)
ax2.step(attribute_values[19:31], underestimation_smooth[19:31], where='mid', linestyle=':', color='saddlebrown', label='Underestimate CF, $g^{-}(x)$')
ax2.set_title('SPECIAL Index Examples (Attribute Values 20-30)')
ax2.set_xlabel('Attribute Values')
ax2.set_ylabel('Sorted Array Offset (CF)')
ax2.grid(True)

# Annotations and highlights
ax2.annotate(f'$g(23) = {lo}$', xy=(23, lo), xytext=(25.5, lo-50), color='dimgray', fontsize=11, arrowprops=dict(color='dimgray', arrowstyle='->'), horizontalalignment='right')
ax2.annotate(f'$g(24) = {hi}$', xy=(24, hi), xytext=(21.5, hi+50), color='dimgray', fontsize=11, arrowprops=dict(color='dimgray', arrowstyle='->'), horizontalalignment='left')
ax2.annotate(f'$g^{{-}}(23) = {lo2}$', xy=(23, lo2), xytext=(24, lo2-65), fontsize=11, arrowprops=dict(facecolor='black', arrowstyle='->'), horizontalalignment='right')
ax2.annotate(f'$g^{{+}}(24) = {hi2}$', xy=(24, hi2), xytext=(23, hi2+65), fontsize=11, arrowprops=dict(facecolor='black', arrowstyle='->'), horizontalalignment='left')
ax2.axhspan(lo, hi, color='steelblue', alpha=0.7, label='True index range')
ax2.axhspan(lo2, hi2, color='lightsteelblue', alpha=0.5, label='SPECIAL index range')
#ax2.plot([22, 22], [lo, hi], marker='|', color='black', markersize=15)
#ax2.plot([24, 24], [lo2, hi2], marker='|', color='black', markersize=15)
#ax2.text(26, (lo + hi) / 2, 'True Index Range', verticalalignment='center', color='black')
#ax2.text(26, (lo2 + hi2) / 2, 'Special Index Range', verticalalignment='center', color='black')
ax2.legend(fontsize=11)

plt.tight_layout()
plt.savefig("index.pdf")
files.download("index.pdf")
plt.show()

